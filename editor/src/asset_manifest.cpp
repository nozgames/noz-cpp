//
//  NoZ - Copyright(c) 2026 NoZ Games, LLC
//

#include "asset_manifest.h"

namespace fs = std::filesystem;

namespace noz::editor {

    static bool SaveStreamIfChanged(Stream* stream, const fs::path& path) {
        if (fs::exists(path)) {
            Stream* existing = LoadStream(nullptr, path);
            if (existing) {
                bool same = GetSize(existing) == GetSize(stream) &&
                    memcmp(GetData(existing), GetData(stream), GetSize(stream)) == 0;
                Free(existing);
                if (same)
                    return false;
            }
        }
        return SaveStream(stream, path);
    }

    const char* ASSET_MANIFEST_HEADER =
        "//\n"
        "// Auto-generated asset header - DO NOT EDIT MANUALLY\n"
        "// Generated by NoZ Game Engine Asset Importer\n"
        "//\n\n";

    struct AssetEntry {
        Document* asset;
        std::string var_name;
        AssetType type;
        std::vector<const Name*> names;
    };

    struct BoneIndex {
        std::string skeleton_name;
        std::string name;
        int index;
        bool last;
    };

    struct ManifestGenerator {
        std::map<const Name*, std::string> names;
        std::set<AssetType> types;
        std::vector<BoneIndex> bones;
        std::vector<AssetEntry> assets;
        fs::path source_path;
        Props* config;
    };

    static void SortAssets(ManifestGenerator& generator);
    static void GenerateCppHeader(ManifestGenerator& generator);
    static void GenerateCppSource(ManifestGenerator& generator);
    static void GenerateLuauDefinitions(ManifestGenerator& generator);
    static void GenerateLuaLoader(ManifestGenerator& generator);

    static std::string GetNameVar(const Name* name) {
        std::string result = name->value;
        Upper(result.data(), static_cast<u32>(result.size()));
        Replace(result.data(), static_cast<u32>(result.size()), '/', '_');
        Replace(result.data(), static_cast<u32>(result.size()), '.', '_');
        Replace(result.data(), static_cast<u32>(result.size()), ' ', '_');
        return result;
    }

    static AssetType ReadAssetHeader(Document* doc, ManifestGenerator& generator, std::vector<const Name*>& out_names) {
        fs::path path = fs::path(g_editor.output_path) / ToString(doc->def->type) / doc->name->value;
        Stream* stream = LoadStream(nullptr, path);
        if (!stream)
            return ASSET_TYPE_UNKNOWN;

        AssetHeader header;
        if (ReadAssetHeader(stream, &header) && header.names > 0){
            if (!IsValidAssetType(header.type))
                return ASSET_TYPE_UNKNOWN;

            const Name** name_table = ReadNameTable(header, stream);
            if (name_table) {
                for (uint32_t i = 0; i < header.names; i++) {
                    generator.names[name_table[i]] = GetNameVar(name_table[i]);
                    out_names.push_back(name_table[i]);
                }

                if (header.type == ASSET_TYPE_SKELETON) {
                    std::string skeleton_name = GetSafeFilename(path.filename().string().c_str()).replace_extension("").string();
                    Upper(skeleton_name.data(), (u32)skeleton_name.size());

                    for (uint32_t i = 0; i < header.names; i++) {
                        std::string bone_name = name_table[i]->value;
                        Upper(bone_name.data(), (u32)bone_name.size());
                        generator.bones.push_back({
                            .skeleton_name = skeleton_name,
                            .name = bone_name,
                            .index = (int)i,
                            .last = i == header.names - 1
                        });
                    }
                }
            }
        }

        Free(stream);

        generator.types.insert(header.type);

        return header.type;
    }

    static bool ReadAsset(Document* doc, ManifestGenerator& generator) {
        if (doc->editor_only || !doc->name)
            return true;

        std::vector<const Name*> names;
        AssetType asset_type = ReadAssetHeader(doc, generator, names);
        if (asset_type == ASSET_TYPE_UNKNOWN)
            return true;

        const char* type_name = ToShortString(asset_type);
        if (!type_name)
            return true;

        // Use original asset type for var_name (e.g., ATLAS_BLOCKS not TEXTURE_BLOCKS)
        const char* var_type_name = ToShortString(doc->def->type);
        std::string var_name = std::string(var_type_name ? var_type_name : type_name) + "_" + doc->name->value;
        Upper(var_name.data(), static_cast<u32>(var_name.size()));

        // Skip if asset with same var_name already exists from an earlier source path
        for (auto& existing : generator.assets) {
            if (existing.var_name == var_name) {
                // Keep the one from the earlier source path (lower asset_path_index)
                if (doc->asset_path_index < existing.asset->asset_path_index) {
                    existing.asset = doc;
                    existing.names = std::move(names);
                }
                return true;
            }
        }

        generator.assets.push_back({
            .asset = doc,
            .var_name = var_name,
            .type = asset_type,
            .names = std::move(names)
        });

        return true;
    }

    static void SortAssets(ManifestGenerator& generator) {
        // Sort assets by var_name for consistent output ordering
        std::ranges::sort(generator.assets.begin(), generator.assets.end(), [](const AssetEntry& a, const AssetEntry& b) {
            return Compare(a.var_name.c_str(), b.var_name.c_str()) < 0;
        });

        // Sort bones by skeleton name, then by index within skeleton
        std::ranges::sort(generator.bones.begin(), generator.bones.end(), [](const BoneIndex& a, const BoneIndex& b) {
            int cmp = Compare(a.skeleton_name.c_str(), b.skeleton_name.c_str());
            if (cmp != 0) return cmp < 0;
            return a.index < b.index;
        });
    }

    // Get sorted names for deterministic output (map is ordered by pointer, not string)
    static std::vector<std::pair<const Name*, std::string>> GetSortedNames(const std::map<const Name*, std::string>& names) {
        std::vector<std::pair<const Name*, std::string>> sorted(names.begin(), names.end());
        std::ranges::sort(sorted, [](const auto& a, const auto& b) {
            return Compare(a.first->value, b.first->value) < 0;
        });
        return sorted;
    }

    bool GenerateAssetManifest(const fs::path& source_path, Props* config) {
        if (fs::exists(source_path) && !fs::is_directory(source_path))
            return false;

        ManifestGenerator generator = {};
        generator.source_path = source_path;
        generator.config = config;

        try
        {
            for (int i = 0; i<GetDocumentCount(); i++)
                ReadAsset(GetDocument(i), generator);
        }
        catch (const std::exception&)
        {
            return false;
        }

        for (const std::string& name_str : config->GetKeys("names"))
        {
            const Name* name = GetName(name_str.c_str());
            generator.names[name] = GetNameVar(name);
        }

        SortAssets(generator);

        if (!GetManifestCppPath().empty()) {
            GenerateCppHeader(generator);
            GenerateCppSource(generator);
        }

        if (!GetManifestLuaPath().empty()) {
            GenerateLuauDefinitions(generator);
#if defined(NOZ_EDITOR_LIB)
            if (!g_editor_traits.skip_lua_loader)
#endif
                GenerateLuaLoader(generator);
        }

        return true;
    }

    static void GenerateCppSource(ManifestGenerator& generator) {
        Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

        fs::path header_path = GetManifestCppPath();
        header_path.replace_extension(".h");

        WriteCSTR(stream, ASSET_MANIFEST_HEADER);
        WriteCSTR(stream, "#include <noz/noz.h>\n");
        WriteCSTR(stream, "#include \"%s\"\n\n", header_path.filename().string().c_str());

        fs::path build_path = GetManifestCppPath().filename();
        build_path.replace_extension("");

        WriteCSTR(stream, "#if defined(NOZ_BUILTIN_ASSETS)\n");
        WriteCSTR(stream, "#include \"%s\"\n", (build_path.string() + "_build.cpp").c_str());
        WriteCSTR(stream, "#endif\n");


        WriteCSTR(stream, "\n// @externs\n");
        for (AssetType asset_type : generator.types) {
            const char* type_name = ToShortString(asset_type);
            std::string type_name_upper = type_name;
            Upper(type_name_upper.data(), (u32)type_name_upper.size());
            WriteCSTR(stream, "extern int %s_COUNT;\n", type_name_upper.c_str());
        }

        for (AssetType asset_type : generator.types) {
            const char* type_name = ToTypeString(asset_type);
            std::string type_name_upper = type_name;
            Upper(type_name_upper.data(), static_cast<u32>(type_name_upper.size()));

            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "// @%s\n", type_name);

            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type)
                    continue;

                WriteCSTR(stream, "%s* %s = nullptr;\n", type_name, asset.var_name.c_str());
            }
        }

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @name\n");
        auto sorted_names = GetSortedNames(generator.names);
        for (auto& kv : sorted_names)
            WriteCSTR(stream, "const Name* NAME_%s = nullptr;\n", kv.second.c_str());

        WriteCSTR(stream,
            "\n"
            "// @path\n");

        for (AssetEntry& asset : generator.assets)
            WriteCSTR(stream, "const Name* PATH_%s = nullptr;\n", asset.var_name.c_str());

        WriteCSTR(stream,
            "\n"
            "// @load\n"
            "bool LoadAssets(Allocator* allocator)\n"
            "{\n");

        WriteCSTR(stream, "    // @name\n");
        for (auto& kv : sorted_names)
            WriteCSTR(stream, "    NAME_%s = GetName(\"%s\");\n", kv.second.c_str(), kv.first->value);

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @path\n");
        for (AssetEntry& asset : generator.assets)
            WriteCSTR(stream, "    PATH_%s = GetName(\"%s\");\n", asset.var_name.c_str(), asset.asset->name->value);

        for (AssetType asset_type : generator.types) {
            const char* type_name = ToString(asset_type);
            std::string type_name_upper = type_name;
            std::string short_name_upper = ToShortString(asset_type);
            std::string full_type_name = ToTypeString(asset_type);
            Upper(type_name_upper.data(), static_cast<u32>(type_name_upper.size()));
            Upper(short_name_upper.data(), static_cast<u32>(short_name_upper.size()));

            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "    // @%s\n", type_name);

            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type)
                    continue;

                WriteCSTR(
                    stream,
                    "    NOZ_LOAD_%s(allocator, PATH_%s, %s);\n",
                    short_name_upper.c_str(),
                    asset.var_name.c_str(),
                    asset.var_name.c_str());
            }

            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "    static %s* _%s[] = {\n", full_type_name.c_str(), short_name_upper.c_str());

            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type)
                    continue;

                WriteCSTR(stream, "        %s,\n", asset.var_name.c_str());
            }

            WriteCSTR(stream, "        nullptr\n");
            WriteCSTR(stream, "    };\n");
            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "    %s = _%s;\n", short_name_upper.c_str(), short_name_upper.c_str());
            WriteCSTR(stream, "    %s_COUNT = sizeof(_%s) / sizeof(void*) - 1;\n", short_name_upper.c_str(), short_name_upper.c_str());

            // Create ATLAS_ARRAY texture array for atlas binding
            if (asset_type == ASSET_TYPE_ATLAS) {
                WriteCSTR(stream, "\n");
                WriteCSTR(stream, "    // Create texture array from all atlases\n");
                WriteCSTR(stream, "    if (ATLAS_COUNT > 0) {\n");
                WriteCSTR(stream, "        ATLAS_ARRAY = CreateTextureArray(allocator, ATLAS, ATLAS_COUNT, GetName(\"atlas_array\"));\n");
                WriteCSTR(stream, "    } else {\n");
                WriteCSTR(stream, "        ATLAS_ARRAY = nullptr;\n");
                WriteCSTR(stream, "    }\n");
            }
        }

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    return true;\n");
        WriteCSTR(stream, "}\n");

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @unload\n");
        WriteCSTR(stream, "void UnloadAssets()\n");
        WriteCSTR(stream, "{");

        for (AssetType asset_type : generator.types) {
            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "    // @%s\n", ToString(asset_type));

            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type)
                    continue;

                WriteCSTR(stream, "    Free(%s);\n",asset.var_name.c_str());
            }

            // Free ATLAS_ARRAY when freeing atlases
            if (asset_type == ASSET_TYPE_ATLAS) {
                WriteCSTR(stream, "    if (ATLAS_ARRAY) { Free(ATLAS_ARRAY); ATLAS_ARRAY = nullptr; }\n");
            }
        }

        WriteCSTR(stream, "}\n");

        WriteCSTR(stream, "\n#ifdef NOZ_LUA\n");
        WriteCSTR(stream, "void BindLuaAssets(noz::lua::State* state) {\n");
        WriteCSTR(stream, "    using namespace noz::lua;\n");

        for (AssetType asset_type : generator.types) {
            if (asset_type == ASSET_TYPE_LUA) continue;

            std::string type_name_upper = ToString(asset_type);
            Upper(type_name_upper.data(), static_cast<u32>(type_name_upper.size()));

            WriteCSTR(stream, "\n    // %s\n", ToString(asset_type));
            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type) continue;
                WriteCSTR(stream, "    SetGlobal(state, \"%s\", %s);\n", asset.var_name.c_str(), asset.var_name.c_str());
            }
        }

        WriteCSTR(stream, "}\n");
        WriteCSTR(stream, "\n#endif\n");

        WriteCSTR(stream, "\n#if !defined(NOZ_BUILTIN_ASSETS)\n");
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "void HotloadAsset(const Name* incoming_name, AssetType incoming_type)\n");
        WriteCSTR(stream, "{");

        for (AssetType asset_type : generator.types) {
            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "    // @%s\n", ToString(asset_type));

            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type)
                    continue;

                std::string type_name_upper = ToString(asset.type);
                Upper(type_name_upper.data(), static_cast<u32>(type_name_upper.size()));

                std::string short_name_upper = ToShortString(asset.type);
                Upper(short_name_upper.data(), static_cast<u32>(short_name_upper.size()));

                WriteCSTR(stream, "    NOZ_RELOAD_%s(PATH_%s, %s);\n", short_name_upper.c_str(), asset.var_name.c_str(), asset.var_name.c_str());
            }
        }

        WriteCSTR(stream, "}\n");
        WriteCSTR(stream, "\n#endif\n");

        SaveStreamIfChanged(stream, GetManifestCppPath());

        Free(stream);
    }

    static void GenerateCppHeader(ManifestGenerator& generator) {
        Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

        WriteCSTR(stream, ASSET_MANIFEST_HEADER);
        WriteCSTR(stream,
            "#pragma once\n\n"
            "#include <noz/core_assets.h>\n"
            "\n"
            "using namespace noz;\n"
            "\n");

        for (AssetType asset_type : generator.types) {
            const char* type_name = ToString(asset_type);
            const char* full_type_name = ToTypeString(asset_type);
            std::string type_name_upper = type_name;
            Upper(type_name_upper.data(), (u32)type_name_upper.size());

            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "// @%s\n", full_type_name);

            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type)
                    continue;

                WriteCSTR(stream, "extern %s* %s;\n", full_type_name, asset.var_name.c_str());
            }
        }

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @name\n");
        auto sorted_names = GetSortedNames(generator.names);
        for (auto& kv : sorted_names)
            WriteCSTR(stream, "extern const Name* NAME_%s;\n", kv.second.c_str());

        if (!generator.bones.empty()) {
            WriteCSTR(stream, "\n");
            for (BoneIndex& bone_index : generator.bones) {
                if (bone_index.index == 0)
                    WriteCSTR(stream, "\n// @BONE_%s\n", bone_index.skeleton_name.c_str());

                WriteCSTR(stream, "constexpr int BONE_%s_%s = %d;\n", bone_index.skeleton_name.c_str(), bone_index.name.c_str(), bone_index.index);

                if (bone_index.last)
                    WriteCSTR(stream, "constexpr int BONE_%s_COUNT = %d;\n", bone_index.skeleton_name.c_str(), bone_index.index + 1);
            }
        }

        // Collect and sort events by name
        std::vector<std::pair<std::string, int>> events;
        for (int asset_index=0, asset_count=GetDocumentCount(); asset_index<asset_count; asset_index++) {
            Document* doc = GetDocument(asset_index);
            if (doc->def->type != ASSET_TYPE_EVENT) continue;
            EventDocument* e = static_cast<EventDocument*>(doc);
            std::string var_name = doc->name->value;
            Upper(var_name.data(), (u32)var_name.size());
            events.push_back({var_name, e->id});
        }
        std::ranges::sort(events, [](const auto& a, const auto& b) {
            return Compare(a.first.c_str(), b.first.c_str()) < 0;
        });
        if (!events.empty()) {
            WriteCSTR(stream, "\n");
            WriteCSTR(stream, "// @event\n");
            for (auto& [var_name, id] : events) {
                WriteCSTR(stream, "constexpr int EVENT_%s = %d;\n", var_name.c_str(), id);
            }
        }

        // Collect and sort palettes by name
        std::vector<std::pair<std::string, int>> palettes;
        for (int palette_index=0, palette_count=g_editor.palette_count; palette_index<palette_count; palette_index++) {
            std::string var_name = g_editor.palettes[palette_index].name->value;
            Upper(var_name.data(), (u32)var_name.size());
            palettes.push_back({var_name, g_editor.palettes[palette_index].id});
        }
        std::ranges::sort(palettes, [](const auto& a, const auto& b) {
            return Compare(a.first.c_str(), b.first.c_str()) < 0;
        });
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @palette\n");
        for (auto& [var_name, id] : palettes) {
            WriteCSTR(stream, "constexpr int PALETTE_%s = %d;\n", var_name.c_str(), id);
        }

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "\nextern bool LoadAssets(Allocator* allocator);\n");
        WriteCSTR(stream, "extern void UnloadAssets();\n");
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "#if !defined(NOZ_BUILTIN_ASSETS)\n");
        WriteCSTR(stream, "extern void HotloadAsset(const Name* incoming_name, AssetType incoming_type);\n");
        WriteCSTR(stream, "#endif\n");

        WriteCSTR(stream, "\n#if defined(NOZ_LUA)\n");
        WriteCSTR(stream, "extern void BindLuaAssets(noz::lua::State* state);\n");
        WriteCSTR(stream, "#endif\n");

        fs::path header_path = GetManifestCppPath();
        header_path.replace_extension(".h");
        SaveStreamIfChanged(stream, header_path);

        Free(stream);
    }

    static const char* GetLuauTypeName(AssetType type) {
        switch (type) {
            case ASSET_TYPE_MESH: return "Mesh";
            case ASSET_TYPE_FONT: return "Font";
            case ASSET_TYPE_TEXTURE: return "Texture";
            case ASSET_TYPE_ATLAS: return "Texture";  // Atlas loads as Texture
            case ASSET_TYPE_SOUND: return "Sound";
            case ASSET_TYPE_SKELETON: return "Skeleton";
            case ASSET_TYPE_ANIMATION: return "Animation";
            case ASSET_TYPE_SHADER: return "Shader";
            case ASSET_TYPE_BIN: return "Bin";
            default: return nullptr;
        }
    }

    static void GenerateLuauDefinitions(ManifestGenerator& generator) {
        Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

        WriteCSTR(stream, "-- Auto-generated asset definitions - DO NOT EDIT MANUALLY\n");
        WriteCSTR(stream, "-- Generated by NoZ Game Engine Asset Importer\n\n");

        // Include globals.d.luau contents
        fs::path globals_path = fs::current_path() / "../noz" / "assets" / "lua" / "globals.d.luau";
        if (fs::exists(globals_path)) {
            Stream* globals_stream = LoadStream(nullptr, globals_path);
            if (globals_stream) {
                u32 size = GetSize(globals_stream);
                if (size > 0) {
                    char* buffer = (char*)Alloc(ALLOCATOR_DEFAULT, size);
                    ReadBytes(globals_stream, buffer, size);
                    WriteBytes(stream, buffer, size);
                    WriteCSTR(stream, "\n");
                    Free(buffer);
                }
                Free(globals_stream);
            }
        }

        for (AssetType asset_type : generator.types) {
            const char* luau_type = GetLuauTypeName(asset_type);
            if (!luau_type) continue;

            WriteCSTR(stream, "-- %s\n", luau_type);
            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type) continue;
                WriteCSTR(stream, "declare %s: %s\n", asset.var_name.c_str(), luau_type);
            }
            WriteCSTR(stream, "\n");
        }

        // Derive .d.luau path from .lua path
        fs::path luau_path = GetManifestLuaPath();
        luau_path.replace_extension(".d.luau");
        SaveStreamIfChanged(stream, luau_path);

        Free(stream);
    }

    static const char* GetLuaLoaderFunc(AssetType type) {
        switch (type) {
            case ASSET_TYPE_MESH: return "LoadMesh";
            case ASSET_TYPE_FONT: return "LoadFont";
            case ASSET_TYPE_TEXTURE: return "LoadTexture";
            case ASSET_TYPE_ATLAS: return "LoadTexture";  // Atlas loads as Texture
            case ASSET_TYPE_SOUND: return "LoadSound";
            case ASSET_TYPE_SKELETON: return "LoadSkeleton";
            case ASSET_TYPE_ANIMATION: return "LoadAnimation";
            case ASSET_TYPE_SHADER: return "LoadShader";
            case ASSET_TYPE_VFX: return "LoadVfx";
            default: return nullptr;
        }
    }

    static void GenerateLuaLoader(ManifestGenerator& generator) {
        Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

        WriteCSTR(stream, "-- Auto-generated asset loader - DO NOT EDIT MANUALLY\n");
        WriteCSTR(stream, "-- Generated by NoZ Game Engine Asset Importer\n\n");

        for (AssetType asset_type : generator.types) {
            const char* loader_func = GetLuaLoaderFunc(asset_type);
            if (!loader_func) continue;

            const char* luau_type = GetLuauTypeName(asset_type);
            WriteCSTR(stream, "-- %s\n", luau_type);
            for (AssetEntry& asset : generator.assets) {
                if (asset.type != asset_type) continue;
                WriteCSTR(stream, "%s = %s(\"%s\")\n", asset.var_name.c_str(), loader_func, asset.asset->name->value);
            }
            WriteCSTR(stream, "\n");
        }

        SaveStreamIfChanged(stream, GetManifestLuaPath());

        Free(stream);
    }
}
